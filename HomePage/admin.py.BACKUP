from django.contrib import admin, messages
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.utils.html import format_html
from django.core.mail import EmailMessage
from datetime import datetime
import requests
import os
import csv
from django.http import HttpResponse
import json

# Import your models
from .models import (
    CustomUser,
    ClientProfile,
    LeadReferrerProfile,
    PropertyBrokerProfile,
    NDARequest,
    LeaseAgreementRequest,
    LeaseAgreementNotaryRequest,
    Property,
    PropertyDocument,
    PropertyImage,
    PropertyFee,
    UploadedFile,
    PropertyEnrollment,
    ChatUsage
)
from .views import get_access_token


# ============================================
# CUSTOM USER ADMIN
# ============================================

@admin.register(CustomUser)
class CustomUserAdmin(BaseUserAdmin):
    """
    Custom admin for CustomUser model with user type badges
    """
    list_display = [
        'email',
        'first_name',
        'last_name',
        'user_type_badge',
        'is_active',
        'is_staff',
        'date_joined'
    ]
    list_filter = ['user_type', 'is_active', 'is_staff', 'is_superuser', 'date_joined']
    search_fields = ['email', 'first_name', 'last_name', 'phone']
    ordering = ['-date_joined']
    
    # Fieldsets for viewing/editing users
    fieldsets = (
        (None, {
            'fields': ('email', 'password')
        }),
        ('Personal Info', {
            'fields': ('first_name', 'last_name', 'phone')
        }),
        ('User Classification', {
            'fields': ('user_type',),
            'description': 'Determines user permissions and profile type'
        }),
        ('Permissions', {
            'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions'),
            'classes': ('collapse',)
        }),
        ('Important Dates', {
            'fields': ('last_login', 'date_joined'),
            'classes': ('collapse',)
        }),
    )
    
    # Fieldsets for adding new users
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'password1', 'password2', 'first_name', 'last_name', 'phone', 'user_type'),
        }),
    )
    
    def user_type_badge(self, obj):
        """Display user type as colored badge"""
        colors = {
            'client': '#28a745',  # Green
            'admin': '#dc3545',   # Red
            'staff': '#007bff',   # Blue
            'lead_referrer': '#ffc107',  # Yellow
            'property_broker': '#17a2b8',  # Teal
        }
        color = colors.get(obj.user_type, '#6c757d')
        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 10px; border-radius: 3px; font-weight: bold;">{}</span>',
            color,
            obj.get_user_type_display()
        )
    user_type_badge.short_description = 'User Type'


# ============================================
# CLIENT PROFILE ADMIN
# ============================================

@admin.register(ClientProfile)
class ClientProfileAdmin(admin.ModelAdmin):
    """
    Admin interface for Client Profiles
    """
    list_display = [
        'client_id',
        'client_alias',
        'get_full_name',
        'get_email',
        'risk_reward',
        'created_at'
    ]
    list_filter = ['risk_reward', 'created_at']
    search_fields = [
        'client_id',
        'client_alias',
        'user__email',
        'user__first_name',
        'user__last_name'
    ]
    readonly_fields = ['client_id', 'client_alias', 'created_at', 'updated_at']
    ordering = ['client_id']
    
    fieldsets = (
        ('Client Identification', {
            'fields': ('user', 'client_id', 'client_alias')
        }),
        ('Investment Profile', {
            'fields': ('investment_thesis', 'financial_goals', 'risk_reward')
        }),
        ('Metadata', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def get_full_name(self, obj):
        return obj.user.get_full_name()
    get_full_name.short_description = 'Name'
    
    def get_email(self, obj):
        return obj.user.email
    get_email.short_description = 'Email'


# ============================================
# LEAD REFERRER PROFILE ADMIN
# ============================================

@admin.register(LeadReferrerProfile)
class LeadReferrerProfileAdmin(admin.ModelAdmin):
    """
    Admin interface for Lead Referrer Profiles
    """
    list_display = [
        'referrer_id',
        'get_full_name',
        'get_email',
        'company_name',
        'commission_rate',
        'is_active',
        'created_at'
    ]
    list_filter = ['is_active', 'created_at']
    search_fields = [
        'referrer_id',
        'company_name',
        'user__email',
        'user__first_name',
        'user__last_name'
    ]
    readonly_fields = ['referrer_id', 'created_at', 'updated_at']
    ordering = ['referrer_id']
    
    fieldsets = (
        ('Referrer Identification', {
            'fields': ('user', 'referrer_id', 'company_name')
        }),
        ('Commission Structure', {
            'fields': ('commission_rate',)
        }),
        ('Banking Information', {
            'fields': ('bank_account_name', 'bank_account_number', 'bank_routing_number'),
            'classes': ('collapse',),
            'description': 'For commission payments'
        }),
        ('Status', {
            'fields': ('is_active',)
        }),
        ('Metadata', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def get_full_name(self, obj):
        return obj.user.get_full_name()
    get_full_name.short_description = 'Name'
    
    def get_email(self, obj):
        return obj.user.email
    get_email.short_description = 'Email'


# ============================================
# PROPERTY BROKER PROFILE ADMIN
# ============================================

@admin.register(PropertyBrokerProfile)
class PropertyBrokerProfileAdmin(admin.ModelAdmin):
    """
    Admin interface for Property Broker Profiles
    """
    list_display = [
        'broker_id',
        'get_full_name',
        'get_email',
        'company_name',
        'license_state',
        'is_verified',
        'is_active',
        'created_at'
    ]
    list_filter = ['is_verified', 'is_active', 'license_state', 'created_at']
    search_fields = [
        'broker_id',
        'company_name',
        'license_number',
        'user__email',
        'user__first_name',
        'user__last_name'
    ]
    readonly_fields = ['broker_id', 'created_at', 'updated_at', 'verification_date']
    ordering = ['broker_id']
    
    fieldsets = (
        ('Broker Identification', {
            'fields': ('user', 'broker_id', 'company_name')
        }),
        ('License Information', {
            'fields': ('license_number', 'license_state')
        }),
        ('Commission Structure', {
            'fields': ('commission_rate',)
        }),
        ('Banking Information', {
            'fields': ('bank_account_name', 'bank_account_number', 'bank_routing_number'),
            'classes': ('collapse',),
            'description': 'For commission payments'
        }),
        ('Verification & Status', {
            'fields': ('is_verified', 'verification_date', 'is_active')
        }),
        ('Metadata', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def get_full_name(self, obj):
        return obj.user.get_full_name()
    get_full_name.short_description = 'Name'
    
    def get_email(self, obj):
        return obj.user.email
    get_email.short_description = 'Email'


# ============================================
# PROPERTY ADMIN (UPDATED)
# ============================================

class PropertyDocumentInline(admin.TabularInline):
    model = PropertyDocument
    extra = 0
    readonly_fields = ['uploaded_at', 'filename']


class PropertyImageInline(admin.TabularInline):
    model = PropertyImage
    extra = 0


class PropertyFeeInline(admin.TabularInline):
    model = PropertyFee
    extra = 1


@admin.register(Property)
class PropertyAdmin(admin.ModelAdmin):
    """
    Admin interface for Properties with approval workflow
    """
    list_display = [
        'reference_number',
        'title',
        'city',
        'state',
        'status_badge',
        'deal_stage',
        'is_featured',
        'completion_percentage',
        'close_date',
        'submitted_by_display'
    ]
    list_filter = [
        'status',
        'deal_stage',
        'is_featured',
        'is_active',
        'is_pipeline',
        'property_type',
        'state',
        'created_at'
    ]
    search_fields = [
        'reference_number',
        'title',
        'address',
        'city',
        'broker_name',
        'broker_user__email'
    ]
    readonly_fields = [
        'completion_percentage',
        'created_at',
        'updated_at',
        'submitted_at',
        'reviewed_at'
    ]
    
    inlines = [PropertyImageInline, PropertyDocumentInline, PropertyFeeInline]
    
    fieldsets = (
        ('Basic Information', {
            'fields': (
                'reference_number',
                'title',
                'property_header',
                'address',
                'property_type',
                'strategies'
            )
        }),
        ('Marketing', {
            'fields': (
                'marketing_title',
                'hero_summary',
                'is_featured'
            ),
            'classes': ('collapse',)
        }),
        ('Location', {
            'fields': (
                'city',
                'state',
                'zip_code',
                'submarket',
                'location_highlights'
            )
        }),
        ('Key Dates', {
            'fields': (
                'loi_date',
                'psa_date',
                'dd_end_date',
                'close_date',
                'deal_stage'
            )
        }),
        ('Building Information', {
            'fields': (
                'total_sf',
                'acres',
                'total_units',
                'vacancy_percent',
                'vacant_sf',
                'walt'
            ),
            'classes': ('collapse',)
        }),
        ('Financial - Primary', {
            'fields': (
                'purchase_price',
                'cap_rate',
                'current_noi',
                'debt_amount',
                'interest_rate',
                'dscr',
                'total_equity',
                'ltv'
            )
        }),
        ('Financial - Extended', {
            'fields': (
                'est_annual_cash_flow',
                'per_100k',
                'est_cash_on_cash',
                'distribution_frequency'
            ),
            'classes': ('collapse',)
        }),
        ('Tenant Information', {
            'fields': (
                'num_tenants',
                'occupancy_percent',
                'lease_structure',
                # Tenant 1
                'tenant_1_name',
                'tenant_1_sf',
                'tenant_1_percent',
                'tenant_1_expiry',
                'tenant_1_guarantee',
                # Tenant 2
                'tenant_2_name',
                'tenant_2_sf',
                'tenant_2_percent',
                'tenant_2_expiry',
                'tenant_2_guarantee',
                # Tenant 3
                'tenant_3_name',
                'tenant_3_sf',
                'tenant_3_percent',
                'tenant_3_expiry',
                'tenant_3_guarantee',
            ),
            'classes': ('collapse',)
        }),
        ('Business Plan', {
            'fields': (
                'business_plan',
                'kbi_1',
                'kbi_2',
                'kbi_3',
                'kbi_4'
            ),
            'classes': ('collapse',)
        }),
        ('Investment Status', {
            'fields': (
                'current_funding',
                'max_investors',
                'current_investors',
                'is_active',
                'is_pipeline'
            )
        }),
        ('Projected Returns', {
            'fields': (
                'projected_irr',
                'hold_period_years'
            )
        }),
        ('Broker Information', {
            'fields': (
                'broker_user',
                'broker_name',
                'broker_email',
                'broker_phone',
                'broker_company',
                'broker_notes'
            ),
            'classes': ('collapse',)
        }),
        ('Approval Workflow', {
            'fields': (
                'status',
                'submitted_by',
                'submitted_at',
                'reviewed_by',
                'reviewed_at',
                'admin_notes'
            )
        }),
        ('Internal', {
            'fields': (
                'internal_notes',
                'completion_percentage'
            ),
            'classes': ('collapse',)
        }),
        ('Metadata', {
            'fields': (
                'created_by',
                'created_at',
                'updated_at'
            ),
            'classes': ('collapse',)
        }),
    )
    
    def status_badge(self, obj):
        """Display status as colored badge"""
        colors = {
            'draft': '#6c757d',         # Gray
            'pending_review': '#ffc107', # Yellow
            'approved': '#28a745',      # Green
            'denied': '#dc3545',        # Red
        }
        color = colors.get(obj.status, '#6c757d')
        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 10px; border-radius: 3px; font-weight: bold;">{}</span>',
            color,
            obj.get_status_display()
        )
    status_badge.short_description = 'Status'
    
    def submitted_by_display(self, obj):
        """Display who submitted the property"""
        if obj.submitted_by:
            return f"{obj.submitted_by.get_full_name()} ({obj.submitted_by.get_user_type_display()})"
        return "N/A"
    submitted_by_display.short_description = 'Submitted By'
    
    def save_model(self, request, obj, form, change):
        """Auto-set created_by on creation"""
        if not change:  # New object
            obj.created_by = request.user
        super().save_model(request, obj, form, change)


# ============================================
# YOUR EXISTING ADMIN CODE (PRESERVED)
# ============================================

@admin.register(LeaseAgreementRequest)
class LeaseAgreementRequestAdmin(admin.ModelAdmin):
    list_display = ('full_name', 'email', 'created_at', 'is_sent')
    list_filter = ['is_sent', 'created_at']
    search_fields = ['full_name', 'email']
    ordering = ['-created_at']
    actions = ['send_invites']

    def send_invites(self, request, queryset):
        token = get_access_token()
        success_count = 0
        failure_count = 0

        for req in queryset.filter(is_sent=False):
            res = requests.post(
                f"https://api.signnow.com/document/{req.document_id}/invite",
                headers={"Authorization": f"Bearer {token}"},
                json={
                    "to": [{"email": req.email, "role": "Signer"}],
                    "from": os.getenv("SIGNNOW_USERNAME"),
                    "subject": "Please Sign Your Lease Agreement",
                    "message": "Click the link to sign your lease agreement."
                }
            )

            if res.status_code == 200:
                req.is_sent = True
                req.save()
                success_count += 1
            else:
                failure_count += 1
                messages.error(
                    request,
                    f"Failed to send to {req.email}: {res.text}"
                )

        if success_count:
            messages.success(
                request,
                f"Sent SignNow invites to {success_count} user(s)."
            )

        if not success_count and not failure_count:
            messages.info(
                request,
                "All selected requests were already sent."
            )

    send_invites.short_description = "Send SignNow invites to selected requests"


@admin.register(LeaseAgreementNotaryRequest)
class LeaseAgreementNotaryRequestAdmin(admin.ModelAdmin):
    list_display = ('full_name', 'email', 'created_at', 'is_sent')
    list_filter = ['is_sent', 'created_at']
    search_fields = ['full_name', 'email']
    ordering = ['-created_at']
    actions = ['send_invites']

    def send_invites(self, request, queryset):
        token = get_access_token()
        success_count = 0
        failure_count = 0

        for req in queryset.filter(is_sent=False):
            res = requests.post(
                f"https://api.signnow.com/document/{req.document_id}/invite",
                headers={"Authorization": f"Bearer {token}"},
                json={
                    "to": [{"email": req.email, "role": "Signer"}],
                    "from": os.getenv("SIGNNOW_USERNAME"),
                    "subject": "Please Sign Your Lease Agreement (Notary Required)",
                    "message": "Click the link to sign your lease agreement."
                }
            )

            if res.status_code == 200:
                req.is_sent = True
                req.save()
                success_count += 1
            else:
                failure_count += 1
                messages.error(
                    request,
                    f"Failed to send to {req.email}: {res.text}"
                )

        if success_count:
            messages.success(
                request,
                f"Sent SignNow invites to {success_count} user(s)."
            )

        if not success_count and not failure_count:
            messages.info(
                request,
                "All selected requests were already sent."
            )

    send_invites.short_description = "Send SignNow invites to selected requests"


@admin.register(NDARequest)
class NDARequestAdmin(admin.ModelAdmin):
    list_display = ('full_name', 'email', 'reason', 'created_at', 'is_sent', 'is_completed')
    list_filter = ['is_sent', 'is_completed', 'created_at']
    search_fields = ['full_name', 'email', 'reason']
    ordering = ['-created_at']
    actions = ['send_invites']

    def send_invites(self, request, queryset):
        token = get_access_token()
        success_count = 0
        failure_count = 0

        for req in queryset.filter(is_sent=False):
            try:
                # Step 1: Get document structure
                doc_res = requests.get(
                    f"https://api.signnow.com/document/{req.document_id}",
                    headers={"Authorization": f"Bearer {token}"}
                )

                if doc_res.status_code != 200:
                    messages.error(request, f"Failed to fetch document for {req.email}")
                    failure_count += 1
                    continue

                doc_data = doc_res.json()

                # Step 2: Pre-fill only Date and Name
                texts_to_fill = []

                for text_field in doc_data.get('texts', []):
                    field_name = text_field.get('name', '').lower()
                    page_num = text_field.get('page_number', 0)

                    if page_num == 0:  # First page only
                        # Fill recipient name
                        if 'recipient' in field_name or 'party b' in field_name or 'other party' in field_name:
                            texts_to_fill.append({
                                "id": text_field['id'],
                                "data": req.full_name
                            })
                        # Fill date
                        elif 'date' in field_name and 'insert date' in field_name.lower():
                            texts_to_fill.append({
                                "id": text_field['id'],
                                "data": datetime.now().strftime('%m/%d/%Y')
                            })

                # Step 3: Send prefill data
                if texts_to_fill:
                    prefill_payload = {"texts": texts_to_fill}

                    prefill_res = requests.put(
                        f"https://api.signnow.com/document/{req.document_id}",
                        headers={
                            "Authorization": f"Bearer {token}",
                            "Content-Type": "application/json"
                        },
                        json=prefill_payload
                    )

                    if prefill_res.status_code not in [200, 201]:
                        messages.warning(request, f"Warning prefilling {req.email}: {prefill_res.text}")

                # Step 4: Send invite with webhook
                webhook_url = "https://www.simpleciti.com/signnow-webhook/"

                invite_res = requests.post(
                    f"https://api.signnow.com/document/{req.document_id}/invite",
                    headers={
                        "Authorization": f"Bearer {token}",
                        "Content-Type": "application/json"
                    },
                    json={
                        "to": [{"email": req.email, "role": "Signer"}],
                        "from": os.getenv("SIGNNOW_USERNAME"),
                        "subject": "Please Sign Your NDA",
                        "message": "Click the link to sign your NDA.",
                        "callback_url": webhook_url
                    }
                )

                if invite_res.status_code == 200:
                    req.is_sent = True
                    req.save()
                    success_count += 1
                else:
                    failure_count += 1
                    messages.error(request, f"Failed to send to {req.email}: {invite_res.text}")

            except Exception as e:
                failure_count += 1
                messages.error(request, f"Error processing {req.email}: {str(e)}")

        if success_count:
            messages.success(request, f"‚úÖ Sent {success_count} invite(s) with pre-filled fields")

        if not success_count and not failure_count:
            messages.info(request, "All selected requests were already sent.")

    send_invites.short_description = "Send SignNow invites (with pre-filled fields)"


@admin.register(PropertyEnrollment)
class PropertyEnrollmentAdmin(admin.ModelAdmin):
    list_display = [
        'email',
        'property_link',
        'sale_price_formatted',
        'equity_rollover_formatted',
        'closing_date',
        'days_remaining',
        'created_at_formatted',
        'has_qi',
        'is_linked'
    ]

    list_filter = [
        'needs_qi_referral',
        'created_at',
        'closing_date',
        'property__property_type'
    ]

    search_fields = [
        'email',
        'qi_name',
        'property__title',
        'property__reference_number',
        'ip_address'
    ]

    readonly_fields = [
        'created_at',
        'ip_address',
        'user_agent',
        'days_remaining',
        'deadline_status'
    ]

    fieldsets = (
        ('Contact Information', {
            'fields': ('email', 'user')
        }),
        ('Transaction Details', {
            'fields': (
                'sale_price',
                'equity_rollover',
                'closing_date',
                'days_remaining',
                'deadline_status'
            )
        }),
        ('Qualified Intermediary', {
            'fields': ('qi_name', 'needs_qi_referral')
        }),
        ('Property', {
            'fields': ('property',)
        }),
        ('Tracking', {
            'fields': ('created_at', 'ip_address', 'user_agent'),
            'classes': ('collapse',)
        })
    )

    ordering = ['-created_at']
    date_hierarchy = 'created_at'

    def property_link(self, obj):
        """Link to property in admin"""
        from django.urls import reverse
        url = reverse('admin:HomePage_property_change', args=[obj.property.pk])
        return format_html('<a href="{}">{}</a>', url, obj.property.reference_number)
    property_link.short_description = 'Property'

    def sale_price_formatted(self, obj):
        """Format sale price as currency"""
        return f"${obj.sale_price:,.2f}"
    sale_price_formatted.short_description = 'Sale Price'
    sale_price_formatted.admin_order_field = 'sale_price'

    def equity_rollover_formatted(self, obj):
        """Format equity as currency"""
        return f"${obj.equity_rollover:,.2f}"
    equity_rollover_formatted.short_description = 'Equity Rollover'
    equity_rollover_formatted.admin_order_field = 'equity_rollover'

    def created_at_formatted(self, obj):
        """Format creation date"""
        return obj.created_at.strftime('%m/%d/%Y %I:%M %p')
    created_at_formatted.short_description = 'Submitted'
    created_at_formatted.admin_order_field = 'created_at'

    def days_remaining(self, obj):
        """Show days until closing"""
        days = obj.get_days_until_closing()
        if days is None:
            return 'N/A'
        if days <= 45:
            return format_html('<span style="color: red; font-weight: bold;">{} days</span>', days)
        elif days <= 180:
            return format_html('<span style="color: orange; font-weight: bold;">{} days</span>', days)
        return f"{days} days"
    days_remaining.short_description = 'Days to Closing'

    def deadline_status(self, obj):
        """Show 1031 deadline status"""
        days = obj.get_days_until_closing()
        if days is None:
            return 'N/A'

        status = []
        if days <= 45:
            status.append('üö® 45-Day ID Deadline!')
        if days <= 180:
            status.append('‚ö†Ô∏è 180-Day Purchase Deadline')

        if status:
            return format_html('<br>'.join(status))
        return '‚úÖ No Immediate Deadlines'
    deadline_status.short_description = '1031 Deadlines'

    def has_qi(self, obj):
        """Show if they have QI or need referral"""
        if obj.needs_qi_referral:
            return '‚ùì Needs Referral'
        elif obj.qi_name:
            return f'‚úÖ {obj.qi_name}'
        return '‚ùå None'
    has_qi.short_description = 'QI Status'

    def is_linked(self, obj):
        """Show if linked to user account"""
        return '‚úÖ' if obj.user else '‚ùå'
    is_linked.short_description = 'Linked'
    is_linked.boolean = True

    actions = ['export_to_csv']

    def export_to_csv(self, request, queryset):
        """Export selected enrollments to CSV"""
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="enrollments_{datetime.now().strftime("%Y%m%d")}.csv"'

        writer = csv.writer(response)
        writer.writerow([
            'Email', 'Sale Price', 'Equity Rollover', 'Closing Date',
            'QI Name', 'Needs QI Referral', 'Property', 'Days to Closing',
            'Submitted', 'IP Address'
        ])

        for enrollment in queryset:
            writer.writerow([
                enrollment.email,
                enrollment.sale_price,
                enrollment.equity_rollover,
                enrollment.closing_date,
                enrollment.qi_name,
                enrollment.needs_qi_referral,
                enrollment.property.reference_number,
                enrollment.get_days_until_closing(),
                enrollment.created_at.strftime('%m/%d/%Y %I:%M %p'),
                enrollment.ip_address
            ])

        return response
    export_to_csv.short_description = 'Export selected to CSV'


# ============================================
# SIMPLE ADMINS FOR OTHER MODELS
# ============================================

@admin.register(PropertyDocument)
class PropertyDocumentAdmin(admin.ModelAdmin):
    list_display = ['property', 'document_type', 'filename', 'uploaded_at', 'uploaded_by']
    list_filter = ['document_type', 'uploaded_at']
    search_fields = ['property__reference_number', 'filename']
    readonly_fields = ['uploaded_at']


@admin.register(UploadedFile)
class UploadedFileAdmin(admin.ModelAdmin):
    list_display = ['title', 'name', 'uploaded_at']
    list_filter = ['uploaded_at']
    search_fields = ['title', 'name']
    readonly_fields = ['uploaded_at']


@admin.register(ChatUsage)
class ChatUsageAdmin(admin.ModelAdmin):
    list_display = ['user', 'message_count', 'first_message_at', 'last_message_at', 'email_sent_at_15']
    list_filter = ['email_sent_at_15', 'first_message_at']
    search_fields = ['user__email', 'user__first_name', 'user__last_name']
    readonly_fields = ['first_message_at', 'last_message_at']


# ============================================
# ADMIN SITE CUSTOMIZATION
# ============================================

admin.site.site_header = "SimpleCiti Administration"
admin.site.site_title = "SimpleCiti Admin"
admin.site.index_title = "Welcome to SimpleCiti Administration"